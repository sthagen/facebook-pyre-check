---
title: Learning Python Types
description: Get to know Python's Type System with working examples
displayed_sidebar: docsSidebar
spug: /
---

# Give Pyrefly a try with some working examples

Python's type system is a powerful tool that helps you write more maintainable, readable, and efficient code. With the help of type hints, you can catch errors early, improve code completion, and make your code more self-documenting.
In this guide, we'll explore the different features of Python's type system, including generics, protocols, dataclasses, typed dictionaries, and overloads. Each section includes a brief description of the feature, along with a working example that you can try out using Pyrefly.

import TryPyre2 from '@site/src/try-pyre2/TryPyre2';

## Generics

Generics allow you to define reusable functions and classes that work with multiple types. This feature enables you to write more flexible and adaptable code.

<pre>
  <TryPyre2
    defaultFlowVersion="1.0.0"
    flowVersions={["1.0.0", "1.1.0"]}
    editorHeight={200}
    codeSample={`# Example: Generic Classes

  from typing import reveal_type

  class C[T]:
      def __init__(self, x: T):
          self.x = x
      def box(self) -> list[T]:
          return [self.x]

  c = C(0)
  reveal_type(c.box())  # revealed type: list[int]
  `}
  />
</pre>

## Protocols

Protocols enable structural typing, which allows you to define interfaces without explicit inheritance. This feature helps you write more modular and composable code.

<pre>
  <TryPyre2
    defaultFlowVersion="1.0.0"
    flowVersions={["1.0.0", "1.1.0"]}
    editorHeight={200}
    codeSample={`# Example: Structural Typing with Protocols
from typing import Iterable, Protocol

class Writer(Protocol):
    def write(self) -> None: ...

class GoodWorld:
    def write(self) -> None:
        print("Hello world!")

class BadWorld:
    pass

def f(writer: Writer):
    pass

f(GoodWorld()) # OK
f(BadWorld())  # ERROR!
  `}
  />
</pre>

## Dataclasses

Protocols enable structural typing, which allows you to define interfaces without explicit inheritance. This feature helps you write more modular and composable code.

<pre>
  <TryPyre2
    defaultFlowVersion="1.0.0"
    flowVersions={["1.0.0", "1.1.0"]}
    editorHeight={200}
    codeSample={`# Example: Dataclasses
  from dataclasses import dataclass
  @dataclass
  class Point:
      x: float
      y: float
  Point(x=0.0, y=0.0)    # OK
  Point(x=0.0, y="oops") # ERROR!
  `}
  />
</pre>


## TypedDict

Typed dictionaries enable you to define dictionaries with specific key-value types. This feature helps you write more robust and maintainable code.

<pre>
  <TryPyre2
    defaultFlowVersion="1.0.0"
    flowVersions={["1.0.0", "1.1.0"]}
    editorHeight={200}
    codeSample={`# Example: TypedDict

from typing import TypedDict

class Movie(TypedDict):
    name: str
    year: int

good_movie: Movie = {"name": "Toy Story", "year": 1995} # OK
bad_movie: Movie = {"name": "The Room", "year": "2003"}  # ERROR!
  `}
  />
</pre>

## Overloads

Overloads allow you to define multiple function signatures for a single function. This feature helps you write more flexible and adaptable code.

<pre>
  <TryPyre2
    defaultFlowVersion="1.0.0"
    flowVersions={["1.0.0", "1.1.0"]}
    editorHeight={200}
    codeSample={`# Example: Overloads
from typing import overload, reveal_type

@overload
def f(x: int) -> int: ...

@overload
def f(x: str) -> str: ...

def f(x: int | str) -> int | str:
    return x

reveal_type(f(0))  # revealed type: int
reveal_type(f("")) # revealed type: str
  `}
  />
</pre>
