--- /home/pradeepkumars/unpatched_typeshed/python-typeshed-8aedbda/stdlib/typing.pyi	2023-02-28 08:50:55.000000000 -0800
+++ stubs/typeshed/typeshed/stdlib/typing.pyi	2023-08-10 16:39:44.629705758 -0700
@@ -18,7 +18,8 @@
     TracebackType,
     WrapperDescriptorType,
 )
-from typing_extensions import Never as _Never, ParamSpec as _ParamSpec, final as _final
+from typing_extensions import Never as _Never, ParamSpec as _ParamSpec, final as _final, Self
+from pyre_extensions import ReadOnly
 
 if sys.version_info >= (3, 10):
     from types import UnionType
@@ -127,7 +128,14 @@
     ]
 
 ContextManager = AbstractContextManager
-AsyncContextManager = AbstractAsyncContextManager
+
+@runtime_checkable
+class AsyncContextManager(Protocol[_T_co]):
+    async def __aenter__(self) -> _T_co: ...
+    @abstractmethod
+    async def __aexit__(
+        self, __exc_type: Type[BaseException] | None, __exc_value: BaseException | None, __traceback: TracebackType | None
+    ) -> bool | None: ...
 
 # This itself is only available during type checking
 def type_check_only(func_or_cls: _F) -> _F: ...
@@ -456,7 +464,7 @@
 class Container(Protocol[_T_co]):
     # This is generic more on vibes than anything else
     @abstractmethod
-    def __contains__(self, __x: object) -> bool: ...
+    def __contains__(self: ReadOnly[Self], __x: ReadOnly[object]) -> bool: ...
 
 @runtime_checkable
 class Collection(Iterable[_T_co], Container[_T_co], Protocol[_T_co]):
@@ -471,11 +479,20 @@
     @overload
     @abstractmethod
     def __getitem__(self, index: slice) -> Sequence[_T_co]: ...
+    @overload
+    @abstractmethod
+    def __getitem__(self: ReadOnly[Self], __i: SupportsIndex) -> ReadOnly[_T_co]: ...
+    @overload
+    @abstractmethod
+    def __getitem__(self: ReadOnly[Self], __s: slice) -> ReadOnly[Self]: ...
     # Mixin methods
     def index(self, value: Any, start: int = 0, stop: int = ...) -> int: ...
     def count(self, value: Any) -> int: ...
     def __contains__(self, value: object) -> bool: ...
+    @overload
     def __iter__(self) -> Iterator[_T_co]: ...
+    @overload
+    def __iter__(self: ReadOnly[Self]) -> Iterator[ReadOnly[_T_co]]: ...
     def __reversed__(self) -> Iterator[_T_co]: ...
 
 class MutableSequence(Sequence[_T], Generic[_T]):
@@ -546,7 +563,10 @@
     def __and__(self, other: Iterable[Any]) -> set[tuple[_KT_co, _VT_co]]: ...
     def __rand__(self, other: Iterable[_T]) -> set[_T]: ...
     def __contains__(self, item: object) -> bool: ...
+    @overload
     def __iter__(self) -> Iterator[tuple[_KT_co, _VT_co]]: ...
+    @overload
+    def __iter__(self: ReadOnly[Self]) -> Iterator[tuple[ReadOnly[_KT_co], ReadOnly[_VT_co]]]: ...
     if sys.version_info >= (3, 8):
         def __reversed__(self) -> Iterator[tuple[_KT_co, _VT_co]]: ...
 
@@ -562,7 +582,10 @@
     def __and__(self, other: Iterable[Any]) -> set[_KT_co]: ...
     def __rand__(self, other: Iterable[_T]) -> set[_T]: ...
     def __contains__(self, key: object) -> bool: ...
+    @overload
     def __iter__(self) -> Iterator[_KT_co]: ...
+    @overload
+    def __iter__(self: ReadOnly[Self]) -> Iterator[ReadOnly[_KT_co]]: ...
     if sys.version_info >= (3, 8):
         def __reversed__(self) -> Iterator[_KT_co]: ...
 
@@ -576,24 +599,35 @@
 class ValuesView(MappingView, Collection[_VT_co], Generic[_VT_co]):
     def __init__(self, mapping: Mapping[Any, _VT_co]) -> None: ...  # undocumented
     def __contains__(self, value: object) -> bool: ...
+    @overload
     def __iter__(self) -> Iterator[_VT_co]: ...
+    @overload
+    def __iter__(self: ReadOnly[Self]) -> Iterator[ReadOnly[_VT_co]]: ...
     if sys.version_info >= (3, 8):
         def __reversed__(self) -> Iterator[_VT_co]: ...
 
 class Mapping(Collection[_KT], Generic[_KT, _VT_co]):
     # TODO: We wish the key type could also be covariant, but that doesn't work,
     # see discussion in https://github.com/python/typing/pull/273.
+    @overload
     @abstractmethod
     def __getitem__(self, __key: _KT) -> _VT_co: ...
+    @overload
+    @abstractmethod
+    def __getitem__(self: ReadOnly[Self], __key: ReadOnly[_KT]) -> ReadOnly[_VT_co]: ...
     # Mixin methods
     @overload
     def get(self, __key: _KT) -> _VT_co | None: ...
     @overload
     def get(self, __key: _KT, default: _VT_co | _T) -> _VT_co | _T: ...
+    @overload
+    def get(self: ReadOnly[Self], __key: ReadOnly[_KT]) -> ReadOnly[_VT_co | None]: ...
+    @overload
+    def get(self: ReadOnly[Self], __key: ReadOnly[_KT], default: ReadOnly[_VT_co | _T]) -> ReadOnly[_VT_co | _T]: ...
     def items(self) -> ItemsView[_KT, _VT_co]: ...
     def keys(self) -> KeysView[_KT]: ...
     def values(self) -> ValuesView[_VT_co]: ...
-    def __contains__(self, __o: object) -> bool: ...
+    def __contains__(self: ReadOnly[Self], __o: ReadOnly[object]) -> bool: ...
 
 class MutableMapping(Mapping[_KT, _VT], Generic[_KT, _VT]):
     @abstractmethod
