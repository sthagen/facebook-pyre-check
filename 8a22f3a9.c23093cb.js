(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{81:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return d}));var a,r=n(3),i=n(7),o=(n(0),n(99)),l={id:"errors",title:"Errors",sidebar_label:"Errors"},s={unversionedId:"errors",id:"errors",isDocsHomePage:!1,title:"Errors",description:"Common Issues",source:"@site/docs/errors.md",slug:"/errors",permalink:"/docs/errors",editUrl:"https://github.com/facebook/pyre-check/tree/master/documentation/website/docs/errors.md",version:"current",sidebar_label:"Errors",sidebar:"pyre",previous:{title:"Types in Python",permalink:"/docs/types-in-python"},next:{title:"Querying Pyre",permalink:"/docs/querying-pyre"}},c=[{value:"Common Issues",id:"common-issues",children:[{value:"Covariance and Contravariance",id:"covariance-and-contravariance",children:[]},{value:"Optional Attributes",id:"optional-attributes",children:[]},{value:"Third-Party Libraries",id:"third-party-libraries",children:[]}]},{value:"Error Codes",id:"error-codes",children:[{value:"0: Unused Ignore",id:"0-unused-ignore",children:[]},{value:"3: Missing Return Annotation",id:"3-missing-return-annotation",children:[]},{value:"4: Missing Attribute Annotation",id:"4-missing-attribute-annotation",children:[]},{value:"5: Missing Global Annotation",id:"5-missing-global-annotation",children:[]},{value:"6: Incompatible Parameter Type",id:"6-incompatible-parameter-type",children:[]},{value:"7: Incompatible Return Type",id:"7-incompatible-return-type",children:[]},{value:"8: Incompatible Attribute Type",id:"8-incompatible-attribute-type",children:[]},{value:"9: Incompatible Variable Type",id:"9-incompatible-variable-type",children:[]},{value:"11, 31: Undefined or Invalid Type",id:"11-31-undefined-or-invalid-type",children:[]},{value:"14,15: Behavioral Subtyping",id:"1415-behavioral-subtyping",children:[]},{value:"16: Missing Attributes",id:"16-missing-attributes",children:[]},{value:"18,21: Undefined Name, Undefined Import",id:"1821-undefined-name-undefined-import",children:[]},{value:"24: Invalid Type Parameters",id:"24-invalid-type-parameters",children:[]},{value:"29: Call Error",id:"29-call-error",children:[]},{value:"33: Prohibited Any",id:"33-prohibited-any",children:[]},{value:"30: Terminating Analysis",id:"30-terminating-analysis",children:[]},{value:"34: Invalid type variable",id:"34-invalid-type-variable",children:[]},{value:"35: Illegal Annotation Target",id:"35-illegal-annotation-target",children:[]},{value:"39: Invalid Inheritance",id:"39-invalid-inheritance",children:[]},{value:"41: Invalid Assignment",id:"41-invalid-assignment",children:[]},{value:"46: Invalid type variance",id:"46-invalid-type-variance",children:[]},{value:"49: Unsafe Cast",id:"49-unsafe-cast",children:[]},{value:"51: Unused Local Mode",id:"51-unused-local-mode",children:[]},{value:"40: Invalid Override",id:"40-invalid-override",children:[]},{value:"53: Missing annotation for captured variables",id:"53-missing-annotation-for-captured-variables",children:[]},{value:"56: Invalid decoration",id:"56-invalid-decoration",children:[]},{value:"57: Incompatible async generator return type",id:"57-incompatible-async-generator-return-type",children:[]}]},{value:"Suppression",id:"suppression",children:[{value:"Suppressing Individual Errors",id:"suppressing-individual-errors",children:[]},{value:"Suppressing All Errors",id:"suppressing-all-errors",children:[]},{value:"Suppressing Errors Across Files",id:"suppressing-errors-across-files",children:[]}]}],p=(a="Internal",function(e){return console.warn("Component "+a+" was not imported, exported, or provided by MDXProvider as global scope"),Object(o.b)("div",e)}),b={rightToc:c};function d(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"common-issues"},"Common Issues"),Object(o.b)("h3",{id:"covariance-and-contravariance"},"Covariance and Contravariance"),Object(o.b)("p",null,Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)"}),"Variance")," is tricky and a common source of confusion for people new to Python's type system."),Object(o.b)("p",null,"Pyre will error when, for instance, a ",Object(o.b)("inlineCode",{parentName:"p"},"List[int]")," is passed in when a ",Object(o.b)("inlineCode",{parentName:"p"},"List[float]")," is expected, as in the following example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def to_seconds(milliseconds: List[float]) -> List[int]:\n  return [int(x/1000.0) for x in milliseconds]\n\nmy_list: List[int] = [1]\nmy_list = to_seconds(my_list) # Pyre errors here!\n")),Object(o.b)("p",null,"This code is works perfectly fine at runtime, and we may think that since ",Object(o.b)("inlineCode",{parentName:"p"},"int")," is a subtype of ",Object(o.b)("inlineCode",{parentName:"p"},"float")," this should not be a problem for the type checker either. However, consider the following code:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def halve_first_element(list: List[float]) -> None:\n  list[0] /= 2\n\nmy_list: List[int] = [1]\nhalve_first_element(my_list)\nfunction_taking_int(my_list[0]) # Oh no, my_list[0] is 0.5!\n")),Object(o.b)("p",null,"If we allowed passing in ",Object(o.b)("inlineCode",{parentName:"p"},"my_list")," to the ",Object(o.b)("inlineCode",{parentName:"p"},"halve_first_element")," function here, the above code would type check. It's perfectly valid from the perspective of the callee to modify the list's element to be a float, as it was annotated as taking a list of floats, but because this list escapes the scope of the callee, we can't allow this in the type checker."),Object(o.b)("p",null,"To work around this, we can signal to the type checker that the parameter can't be modified. Here's how you can tell the type checker that you won't change the container in your function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"# I can't modify milliseconds here, so it's safe to pass a Iterable[int].\ndef to_seconds(milliseconds: Iterable[float]) -> List[int]:\n  return [int(x/1000.0) for x in milliseconds]\n\nmy_list: List[int] = [1]\nmy_list = to_seconds(my_list) # Type checks!\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"typing.Iterable")," is an immutable variant for lists that allows accessing the list without modifying it. Most commonly used generic containers have immutable variants, and I would encourage you to use them for function parameters whenever you don't need to modify a container in your function.\nHere are some immutable variants for commonly used containers:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"typing.List \u2192 typing.Sequence (if you need random access via my_list[id])\ntyping.List \u2192 typing.Iterable (if you're just iterating over the list in a loop and want to support sets as well)\ntyping.Dict \u2192 typing.Mapping\ntyping.Set \u2192 typing.AbstractSet\n")),Object(o.b)("p",null,"Invariance, combined with type inference, comes with a few gotchas. When you write an expression, Pyre infers the most precise type possible. For instance, Pyre infers the ",Object(o.b)("inlineCode",{parentName:"p"},"List[int]")," type for ",Object(o.b)("inlineCode",{parentName:"p"},"[1, 2]"),", even though ",Object(o.b)("inlineCode",{parentName:"p"},"List[float]")," would be a perfectly valid type here. This can cause issues, as in the following example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def zeroes(number_of_elements: int) -> List[float]:\n  a = [0] * number_of_elements\n  return a # Pyre errors here!\n")),Object(o.b)("p",null,"What happened above is that Pyre inferred a type of ",Object(o.b)("inlineCode",{parentName:"p"},"List[int]")," for a, and invariance kicked in. You can work around this by adding an explicit annotation when declaring a:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def zeroes(number_of_elements: int) -> List[float]:\n  a: List[float] = [0] * number_of_elements\n  return a # Type checks!\n")),Object(o.b)("h3",{id:"optional-attributes"},"Optional Attributes"),Object(o.b)("p",null,"A common pattern in Python is to check whether an attribute is ",Object(o.b)("inlineCode",{parentName:"p"},"None")," before accessing its value. E.g."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"from typing import Optional\n\nclass Data:\n  field: Optional[int]\n\ndef process_field(input: int) -> None:\n  ...\n\ndef process_data(data: Data) -> None:\n  if data.field:\n    # ...\n    process_field(data.field)  # Error: expected `int` but got `Optional[int]`\n")),Object(o.b)("p",null,"The above fails to type-check because Pyre cannot guarantee that ",Object(o.b)("inlineCode",{parentName:"p"},"data.field")," is not ",Object(o.b)("inlineCode",{parentName:"p"},"None")," even after checking explicitly in the line before: ",Object(o.b)("inlineCode",{parentName:"p"},"field")," could be set to ",Object(o.b)("inlineCode",{parentName:"p"},"None")," by another thread or it could be a property that returns something different the next time we access it."),Object(o.b)("p",null,"The preferred way to make this code type-check is to mark the attribute ",Object(o.b)("inlineCode",{parentName:"p"},"Final"),", i.e. to specify that it can't be reassigned."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"from typing import Final, Optional\n\nclass Data:\n  # Needs to be assigned in the constructor and cannot be changed afterwards.\n  field: Final[Optional[int]] = 1\n")),Object(o.b)("p",null,"It is always safe to refine attributes when their types are ",Object(o.b)("inlineCode",{parentName:"p"},"Final"),"."),Object(o.b)("p",null,"Alternatively, it is also safe to assign the attribute to a local variable before accessing its value."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def process_data(data: Data) -> None:\n  field = data.field\n  if field:\n    process_field(field)\n")),Object(o.b)("h3",{id:"third-party-libraries"},"Third-Party Libraries"),Object(o.b)("p",null,"Not all third-party libraries come with Python code that Pyre can analyze (e.g. ",Object(o.b)("inlineCode",{parentName:"p"},"cython")," modules), and some libraries contain source code without annotations. This will often show up in the form of undefined attribute errors:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"Undefined attribute [16]: Module <library> has no attribute <some attribute>.\n")),Object(o.b)("p",null,"Since it is not always possible to annotate code, PEP 484 specifies a format for ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://www.python.org/dev/peps/pep-0484/#stub-files"}),"stub files")," with a ",Object(o.b)("inlineCode",{parentName:"p"},".pyi")," extension. Pyre will look for stub files in ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/python/typeshed"}),"typeshed"),", or next to your source code. You can also provide additional paths to Pyre to look for stubs (see ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/configuration"}),"Configuration"),")."),Object(o.b)(p,{mdxType:"Internal"}),Object(o.b)("h2",{id:"error-codes"},"Error Codes"),Object(o.b)("p",null,"Different errors raised by Pyre have different error codes. E.g. in"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-bash"}),"(venv) $ pyre\n \u019b Found 1 type error!\ntest.py:1:0 Incompatible variable type [9]: a is declared to have type `int` but is used as type `str`.\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"9")," in the brackets indicates that we raised an error with code 9."),Object(o.b)("h3",{id:"0-unused-ignore"},"0: Unused Ignore"),Object(o.b)("p",null,"Pyre fixmes and ignores allow you to ignore specific type errors by their code until you are able to fix them. In order to avoid outdated fixme comments in your project, Pyre will also error when a fixme is no longer needed. Removing the fixme comment will resolve the error."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"# pyre-fixme[7] # unused ignore\ndef foo() -> int:\n  return 1\n")),Object(o.b)("h3",{id:"3-missing-return-annotation"},"3: Missing Return Annotation"),Object(o.b)("p",null,"If strict mode is turned on, Pyre will error when a function is either annotated with a return type that contains ",Object(o.b)("inlineCode",{parentName:"p"},"typing.Any"),", or is not annotated with any return type at all (in which case Pyre will treat it as returning ",Object(o.b)("inlineCode",{parentName:"p"},"typing.Any")," by default)."),Object(o.b)("p",null,"This is bad because a return type of ",Object(o.b)("inlineCode",{parentName:"p"},"typing.Any")," may potentially hiding legitimate type errors that may happen at runtime:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'from typing import Any\n\ndef f():\n  return 42\n\n# This line will raise at runtime, but no type error here since `f()` has type `Any`.\nprint("a" + f())\n')),Object(o.b)("p",null,"The best way to silence this error is to add non-",Object(o.b)("inlineCode",{parentName:"p"},"Any")," return annotation to every function."),Object(o.b)("h3",{id:"4-missing-attribute-annotation"},"4: Missing Attribute Annotation"),Object(o.b)("p",null,"In strict mode, Pyre will error when an attribute does not have an annotation."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"class A:\n    b = foo() # Missing attribute annotation\n")),Object(o.b)("p",null,"Adding a type annotation will resolve this error."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"class A:\n  b: int = foo()\n")),Object(o.b)("h3",{id:"5-missing-global-annotation"},"5: Missing Global Annotation"),Object(o.b)("p",null,"If strict mode is turned on, Pyre will error when a globally accessible variable is not annotated. If pyre was able to infer a type for the\nvariable, it will emit this type in the error message. The fix is usually to add an annotation to the variable."),Object(o.b)("p",null,"Note: This error has also arisen when there is some ambiguity of whether a declaration is a global expression or a type alias, in these cases pyre assumes it is an expression. Adding a ",Object(o.b)("inlineCode",{parentName:"p"},": TypeAlias")," annotation lets pyre know that it is a type alias and solves the problem."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'from typing_extensions import TypeAlias\n\n# This declaration would result in an error\nMyTypeAlias = Dict[str, "AnotherTypeAlias"]\n\n# This declaration ensures that pyre knows MyTypeAlias is a type alias\nMyTypeAlias: TypeAlias = Dict[str, "AnotherTypeAlias"]\n')),Object(o.b)("h3",{id:"6-incompatible-parameter-type"},"6: Incompatible Parameter Type"),Object(o.b)("p",null,"Pyre will error if an argument passed into a function call does not match the expected parameter type of that function."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def takes_int(x: int) -> None:\n  pass\ndef f(x: Optional[int]) -> None:\n  takes_int(x) # Incompatible parameter type error\n")),Object(o.b)("p",null,"If you are seeing errors with invariant containers where some ",Object(o.b)("inlineCode",{parentName:"p"},"Container[T]")," is expected but you are passing ",Object(o.b)("inlineCode",{parentName:"p"},"Container[S]")," where ",Object(o.b)("inlineCode",{parentName:"p"},"S < T"),", please see ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"errors#covariance-and-contravariance"}),"Covariance and Contravariance"),"."),Object(o.b)("h3",{id:"7-incompatible-return-type"},"7: Incompatible Return Type"),Object(o.b)("p",null,"Pyre will error when the value returned from a function does not match the annotation."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'def foo() -> int:\n  return "" # incompatible return type\n')),Object(o.b)("p",null,"Updating the return annotation, or the value returned from the function will resolve this error."),Object(o.b)("h3",{id:"8-incompatible-attribute-type"},"8: Incompatible Attribute Type"),Object(o.b)("p",null,"Pyre will error if a value is assigned to an attribute that does not match the annotated type of that attribute."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'class Foo:\n  x: int = 0\n\ndef f(foo: Foo) -> None:\n  foo.x = "abc" # Incompatible attribute type error\n')),Object(o.b)("p",null,"If you are seeing errors with invariant containers where some ",Object(o.b)("inlineCode",{parentName:"p"},"Container[T]")," is expected but you are passing ",Object(o.b)("inlineCode",{parentName:"p"},"Container[S]")," where ",Object(o.b)("inlineCode",{parentName:"p"},"S < T"),", please see ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"errors#covariance-and-contravariance"}),"Covariance and Contravariance"),"."),Object(o.b)("h3",{id:"9-incompatible-variable-type"},"9: Incompatible Variable Type"),Object(o.b)("p",null,"Pyre will error when assigning incompatible types to local variables and parameters that were explicitly annotated."),Object(o.b)("p",null,"That is, the following will error:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'def f(x: int) -> None:\n  x = "" # Incompatible variable type error\n  y: int = 1\n  y = "" # Incompatible variable type error\n')),Object(o.b)("p",null,"The rationale here is that it's surprising for an explicitly annotated variable to have an\nincompatible type later on in the same function."),Object(o.b)("p",null,"If you are constructing an object that is generic over an invariant type, you may run into an error:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"_T = TypeVar('_T')\n\nclass Foo(Generic[_T]):\n    def __init__(self, x: _T) -> None: ...\n\ndef f() -> None:\n    foo: Foo[Optional[int]] = Foo(x=1) # Incompatible variable type error\n")),Object(o.b)("p",null,"This is due to the fact that ",Object(o.b)("inlineCode",{parentName:"p"},"Foo[X]")," is not less than ",Object(o.b)("inlineCode",{parentName:"p"},"Foo[Y]")," even if ",Object(o.b)("inlineCode",{parentName:"p"},"X < Y")," when the type variable is invariant.\nYou can declare your intention to initialize the object with a wider type than is given to fix this error:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def f() -> None:\n    foo: Foo[Optional[int]] = Foo[Optional[int]](x=1)\n")),Object(o.b)("h3",{id:"11-31-undefined-or-invalid-type"},"11, 31: Undefined or Invalid Type"),Object(o.b)("p",null,"Pyre recognizes class names as valid annotations. Most basic types are imported from the ",Object(o.b)("inlineCode",{parentName:"p"},"typing")," module or are already available from builtins like ",Object(o.b)("inlineCode",{parentName:"p"},"str"),", ",Object(o.b)("inlineCode",{parentName:"p"},"int"),", ",Object(o.b)("inlineCode",{parentName:"p"},"bool"),", etc. You can also define your own type alias on the global scope, which can be used as annotations:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"from typing_extensions import TypeAlias\n\nINT_OR_STR: TypeAlias = Union[int, str]\n")),Object(o.b)("p",null,"If you use a name as an annotation that is not a valid type or valid alias, you will see this error:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'GLOBAL_VALUE = "string"\n\ndef f0() -> GLOBAL_VALUE: ... # Error! `GLOBAL_VALUE` is a value, not a type.\n\ndef f1() -> type(GLOBAL_VALUE): ...   # Error! Static type annotations cannot be dynamically computed.\n\ndef f2() -> [int]: ...  # Error! `[int]` is not a valid type. If you mean a list of int, use `typing.List[int]`.\n\ndef f3() -> (int, str): ...  # Error! `(int, str)` is not a valid type. If you mean a pair of int and str, use `typing.Tuple[int, str]`.\n\nfrom typing import Callable\ndef f4() -> Callable[[int]]: ...  # Error! `Callable[[int]]` is not a valid type because the return type of the callable is missing. Good example: `Callable[[int], int]`.\n\ndef f5() -> Callable[int, int]: ...  # Error! `Callable[int, int]` is not a valid type. The parameter types of the callable must be enclosed in square brackets. Good example: `Callable[[int], int]`.\n\nfrom typing_extensions import Final\ndef f6() -> List[Final[int]]: ...  # Error! `Final` may only be used as the outermost type in annotations. See PEP 591.\n\nfrom typing_extensions import Literal\ndef f7() -> Literal[GLOBAL_VALUE]: ...  # Error! Only literals are allowed as parameters for `Literal`. See PEP586. Good example: `Literal[42]` or `Literal["string"]`.\n')),Object(o.b)("p",null,"You can fix this error by verifying that your annotation is"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"statically determined."),Object(o.b)("li",{parentName:"ol"},"properly imported from ",Object(o.b)("inlineCode",{parentName:"li"},"typing")," if applicable."),Object(o.b)("li",{parentName:"ol"},"properly defined in the module you are importing from. If the module you are importing from has a ",Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"#third-party-libraries"}),"stub file"),", you should check the definition there."),Object(o.b)("li",{parentName:"ol"},"properly adhere to the additional rules of special types (e.g. ",Object(o.b)("inlineCode",{parentName:"li"},"Callable"),", ",Object(o.b)("inlineCode",{parentName:"li"},"Final"),", and ",Object(o.b)("inlineCode",{parentName:"li"},"Literal"),").")),Object(o.b)("p",null,"For type aliases, check that your type alias is defined"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"with a valid type on the RHS. If you provide an annotation for the TypeAlias assignment, it must be ",Object(o.b)("inlineCode",{parentName:"li"},"typing_extensions.TypeAlias"),"."),Object(o.b)("li",{parentName:"ol"},"on the global scope, not nested inside a function or class.")),Object(o.b)("h3",{id:"1415-behavioral-subtyping"},"14,15: Behavioral Subtyping"),Object(o.b)("p",null,"Method overrides should follow\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Liskov_substitution_principle"}),"Liskov's substitution principle"),".\nIn short, parameter types can't be more restrictive and return types\ncan't be more permissive in overridden methods. To see why, consider the following example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def width(image: Image) -> float:\n    return image.width()\n")),Object(o.b)("p",null,"Say we now have different implementations of our ",Object(o.b)("inlineCode",{parentName:"p"},"Image")," class, one of which\nviolates the substitution principle:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"class Image:\n    @abstractmethod:\n    def width() -> float: pass\n\nclass JpegImage(Image):\n    @override\n    def width() -> int: return 10  # this is fine\n\nclass ComplexImage(Image):\n    @override\n    def width() -> complex: return 1j\n\ndef foo() -> None:\n    image: Image = ComplexImage()\n    print(int(image.width()))\n")),Object(o.b)("p",null,"The above code fails at runtime with ",Object(o.b)("inlineCode",{parentName:"p"},"TypeError: can't convert complex to int"),". The case for parameters follows analogously."),Object(o.b)("h4",{id:"common-reasons"},"Common Reasons"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"Could not find parameter y in overriding signature."),": Check if the overriding function can accept all arguments that the overridden function can."),Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"class Base:\n    def foo(self, x: int, y: str) -> None:\n        pass\n\nclass Child(Base):\n    def foo(self, x: int) -> None:\n        pass\n"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"Type Foo is not a subtype of the overridden attribute type Bar"),":"),Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'class Base:\n    a: int = 0\nclass Child(Base):\n    a: str = ""\n\ndef foo() -> None:\n    base: Base = Child()\n    base.a + 1\n')),Object(o.b)("p",{parentName:"li"},"This would fail at runtime with ",Object(o.b)("inlineCode",{parentName:"p"},'TypeError: can only concatenate str (not "int") to str'),".")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"Returned type Foo is not a subtype of the overridden return Bar."),": Check for reasons like ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#covariance-and-contravariance"}),"invariance"),"."))),Object(o.b)("h3",{id:"16-missing-attributes"},"16: Missing Attributes"),Object(o.b)("p",null,"Your code is most likely trying to access an attribute that Pyre does not know about.\nPyre has various ways of inferring what is an attribute of an object:"),Object(o.b)("h4",{id:"explicitly-declare-the-attribute"},"Explicitly Declare the Attribute"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"class Derp:\n    my_attribute: int = 1\n\n    @property\n    def my_property(self) -> int: ...\n")),Object(o.b)("h4",{id:"implicitly-declare-the-attribute"},"Implicitly Declare the Attribute"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"class Derp:\n    def __init__(self, foo: str) -> None:\n        self.my_attribute: int = 1\n\n        # The `foo` attribute is inferred to have type `str` because the\n        # parameter `foo` has type `str`.\n        self.foo = foo\n")),Object(o.b)("p",null,"Pyre does one level of inlining to infer implicit parameters\nWe suggest you do not heavily rely on this feature as it is not sound and makes our code brittle.\nSupport for this is temporary."),Object(o.b)("h4",{id:"common-reasons-1"},"Common Reasons"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"Optional type has no attribute foo."),": See ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#optional-attributes"}),"Optional attributes"),".")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"Foo has no attribute bar."),": Check if you have explicitly provided the type for ",Object(o.b)("inlineCode",{parentName:"p"},"bar")," either in the constructor or as a class attribute.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"Module foo has no attribute bar"),": Check if the library has ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#third-party-libraries"}),"stubs"),". If so, you may need to add the function, class, or global variable to the stub.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"A library class has an attribute but it is not recognized by Pyre: Check if the library has ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#third-party-libraries"}),"stubs"),". If so, you may need to add the attribute to the class in the stub.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Your class has dynamic attributes: Consider using ",Object(o.b)("inlineCode",{parentName:"p"},"__getattr__")," in a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/types-in-python#when-source-code-is-not-available"}),"stub")," so that Pyre doesn't complain about those attributes."))),Object(o.b)("h3",{id:"1821-undefined-name-undefined-import"},"18,21: Undefined Name, Undefined Import"),Object(o.b)("p",null,'Error 18 ("Undefined name") is raised when your code tries to access a variable or function that Pyre could not resolve.\nThis is usually caused by failing to import the proper module.'),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"  # 'import some_module' is missing\n  some_module.some_func()\n")),Object(o.b)("p",null,'Pyre will raise error 21 instead ("Undefined import") when the import statement is present, but the module to be imported could not be found in the search path.\nIf the module provides stub files, please provide their location via the ',Object(o.b)("inlineCode",{parentName:"p"},"--search-path")," commandline parameter."),Object(o.b)("h3",{id:"24-invalid-type-parameters"},"24: Invalid Type Parameters"),Object(o.b)("p",null,"Pyre will error if a generic type annotation is given with unexpected type parameters."),Object(o.b)("h4",{id:"generic-type-expects-x-type-parameters-"},'"Generic type expects X type parameters ..."'),Object(o.b)("p",null,"Either too few or too many type parameters were provided for the container type. For example,"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"x: List[int, str] = [] # Invalid type parameters error\n")),Object(o.b)("p",null,"In this case, ",Object(o.b)("inlineCode",{parentName:"p"},"typing.List")," is a generic type taking exactly one type parameter. If we pass a single parameter, this resolves the issue."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"x: List[Union[int, str]] = [] # No error\n")),Object(o.b)("p",null,"If you do not know or do not want to specify the type parameters, use ",Object(o.b)("inlineCode",{parentName:"p"},"typing.Any")," but still ensure the arity is correct."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"x: List = [] # Invalid type parameters error\nx: List[Any] = [] # No error\n")),Object(o.b)("p",null,"Note: You may see a suggestion to use ",Object(o.b)("inlineCode",{parentName:"p"},"typing.List")," instead of builtins ",Object(o.b)("inlineCode",{parentName:"p"},"list")," as the type annotation when providing type parameters. This is to avoid runtime errors, because the builtin ",Object(o.b)("inlineCode",{parentName:"p"},"list")," does not support subscripting and ",Object(o.b)("inlineCode",{parentName:"p"},"list[int]")," is therefore not runtime-friendly."),Object(o.b)("h4",{id:"non-generic-type-cannot-take-type-parameters-"},'"Non-generic type cannot take type parameters ..."'),Object(o.b)("p",null,"Type parameters are only meaningful if the container type is generic. Passing in the type parameter binds the provided parameter type to the generic in the container class. For example,"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"class Container:\n  def add(element: int) -> None: ...\n  def get_element() -> int: ...\n\nx: Container[int] = Container() # Invalid type parameter error\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"T = TypeVar('T')\n\nclass Container(Generic[T]):\n  def add(element: T) -> None: ...\n  def get_element() -> T: ...\n\nx: Container[int] = Container()\nx.get_element() # returns int\n\ny: Container[str] = Container()\ny.get_element() # returns str\n")),Object(o.b)("h4",{id:"type-parameter-violates-constraints-"},'"Type parameter violates constraints ..."'),Object(o.b)("p",null,"If a container class is generic over a type variable with given type bounds, any type parameter used must comply with those type bounds. For example,"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"T = TypeVar('T', bound=Union[int, bool])\n\nclass Container(Generic[T]):\n  def add(element: T) -> None: ...\n  def get_element() -> T: ...\n\nx: Container[int] = Container() # No error\n\ny: Container[str] = Container() # Invalid type parameter error\n")),Object(o.b)("h3",{id:"29-call-error"},"29: Call Error"),Object(o.b)("p",null,"Pyre will emit an error on seeing a call of one of the following types:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"The called object is not a function. This means that its inferred type is not Callable and it is not an instance of a class which implements a ",Object(o.b)("inlineCode",{parentName:"p"},"__call__")," method. This could happen due to user error (the object is indeed not a function) or due to an incorrect or incomplete type stub for the object's class causing pyre to infer the wrong type.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"The call cannot be safely typed since the types and kinds of its parameters depend on a type variable. This is seen when the callable is typed using a ParameterSpecification type variable and the ",Object(o.b)("inlineCode",{parentName:"p"},"*args")," and ",Object(o.b)("inlineCode",{parentName:"p"},"**kwargs")," are not passed into the call correctly, i.e. together and in order. (For more details see ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://www.python.org/dev/peps/pep-0612/#the-components-of-a-paramspec"}),"PEP 612"),")"))),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'from pyre_extensions import ParameterSpecification\n\nP = ParameterSpecification("P")\n\ndef decorator(f: Callable[P, int]) -> Callable[P, None]:\n\n  def foo(*args: P.args, **kwargs: P.kwargs) -> None:\n\n    f(*args, **kwargs)    # Accepted, should resolve to int\n\n    f(*args)              # Rejected\n\n    f(*kwargs, **args)    # Rejected\n\n    f(1, *args, **kwargs) # Rejected\n\n  return foo\n')),Object(o.b)("h3",{id:"33-prohibited-any"},"33: Prohibited Any"),Object(o.b)("p",null,"Pyre will warn on any usage of ",Object(o.b)("inlineCode",{parentName:"p"},"typing.Any")," when run in ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"types-in-python#strict-mode"}),"strict mode"),". ",Object(o.b)("inlineCode",{parentName:"p"},"Any")," is an escape hatch that hides type errors and introduces potential type inconsistencies which Pyre strict is designed to make explicit. To resolve this error, replace ",Object(o.b)("inlineCode",{parentName:"p"},"Any")," with any other annotation. Using builtins ",Object(o.b)("inlineCode",{parentName:"p"},"object")," is acceptable if you are looking for a supertype of all classes."),Object(o.b)("h3",{id:"30-terminating-analysis"},"30: Terminating Analysis"),Object(o.b)("p",null,"This indicates a bug in Pyre. Please open an issue on ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/facebook/pyre/issues"}),"Github"),"."),Object(o.b)("h3",{id:"34-invalid-type-variable"},"34: Invalid type variable"),Object(o.b)("p",null,"Example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"class Base:\n    foo: List[T] = []\n\n$ pyre\nInvalid type variable [34]: The current class isn't generic with respect to the type variable `Variable[T]`.\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def foo(x: int) -> List[T]:\n    return [x, x]\n\n$ pyre\nInvalid type variable [34]: The type variable `Variable[T]` isn't present in the function's parameters.\n")),Object(o.b)("p",null,'Type variables can only be used as types when they have already been placed "in scope".\nA type variable can be placed into scope via:'),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Generic class declarations",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"for example, ",Object(o.b)("inlineCode",{parentName:"li"},"class C(Generic[T]):")," puts ",Object(o.b)("inlineCode",{parentName:"li"},"T")," into scope for the body of the class"))),Object(o.b)("li",{parentName:"ul"},"The ",Object(o.b)("strong",{parentName:"li"},"parameter")," types of a generic function",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"for example, ",Object(o.b)("inlineCode",{parentName:"li"},"def foo(x: T)")," puts ",Object(o.b)("inlineCode",{parentName:"li"},"T")," into scope for the body and return type annotation of the function")))),Object(o.b)("p",null,"Suggested fix:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"class Base(Generic[T]):\n    foo: List[T] = []\n\nbase: Base[int]\n\ndef foo(x: T) -> List[T]:\n    return [x, x]\n")),Object(o.b)("h4",{id:"decorator-factories"},"Decorator Factories"),Object(o.b)("p",null,"One common error is when defining a generic decorator factory. The Python type system doesn't currently place ",Object(o.b)("inlineCode",{parentName:"p"},"T")," into scope within a ",Object(o.b)("inlineCode",{parentName:"p"},"Callable")," type. So, it considers ",Object(o.b)("inlineCode",{parentName:"p"},"T")," to be a type variable from the outer scope. This can lead to errors for apparently valid code:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"from typing import *\n\nT = TypeVar(\"T\")\nR = TypeVar(\"R\")\n\ndef my_decorator_factory(message: str) -> Callable[[Callable[[T], R]], Callable[[T], R]]:\n\n    def _decorator(f: Callable[[T], R]) -> Callable[[T], R]:\n\n        def _inner(x: T) -> R:\n            print(message)\n            return f(x)\n\n        return _inner\n\n    return _decorator\n\n$ pyre\nInvalid type variable [34]: The type variable `Variable[R]` isn't present in the function's parameters.\nInvalid type variable [34]: The type variable `Variable[T]` isn't present in the function's parameters.\n")),Object(o.b)("p",null,"Suggested fix: Use a callback protocol to define the return type."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'from typing import *\n\nT = TypeVar("T")\nR = TypeVar("R")\n\nclass MyCallableProtocol(Protocol):\n    def __call__(self, __f: Callable[[T], R]) -> Callable[[T], R]: ...\n\ndef my_decorator_factory(message: str) -> MyCallableProtocol:\n\n    def _decorator(f: Callable[[T], R]) -> Callable[[T], R]:\n\n        def _inner(x: T) -> R:\n            print(message)\n            return f(x)\n\n        return _inner\n\n    return _decorator\n')),Object(o.b)("h3",{id:"35-illegal-annotation-target"},"35: Illegal Annotation Target"),Object(o.b)("p",null,"Pyre will error when a type annotation is applied to something that can't be annotated. This could happen when:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"A variable is re-annotated after first declaration or an explicity annotated function parameter is re-annotated within the function body. This is not allowed as re-annotating variables reduces readability and causes the annotation of a variable to depend on the position in control flow.")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def transformation(p: int) -> str:\n  return str(p + 1)\n\ndef foo(x: int) -> None:\n  y: int = x + 2\n  z = x + 3\n\n  # Each of the following will produce an error\n  x: str = transformation(x)\n  y: str = transformation(y)\n  z: int = 4\n")),Object(o.b)("p",null,"An easy fix for the first two errors is to use a new variable rather than re-annotating the old variable so it can hold a new type. For the third error, ",Object(o.b)("inlineCode",{parentName:"p"},"z")," should have been annotated at first declaration."),Object(o.b)("ol",{start:2},Object(o.b)("li",{parentName:"ol"},"Trying to annotate non-self attributes, i.e annotating the attributes of a different class than the one whose scope you are in:")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'class Foo:\n  attribute: int = 1\n\nclass Bar:\n  def __init__(self):\n    Foo.attribute: str = "hello"\n\ndef some_method() -> None:\n  Foo.attribute: int = 5\n')),Object(o.b)("p",null,"This is not allowed as Pyre needs to be able to statically determine the type of globally accessible values, including class attributes. Even if Pyre followed control flow across functions to determine class attribute annotations, such re-annotations imply very dynamic behavior that makes the code difficult to work with."),Object(o.b)("p",null,"The fix for this situation, similar to the case above, is to annotate the class attribute at its definition in the class that owns it and remove any annotations elsewhere. If this attribute is from a third party library, then you can add a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"errors#third-party-libraries"}),"stub")," for the class and annotate the attribute there."),Object(o.b)("h3",{id:"39-invalid-inheritance"},"39: Invalid Inheritance"),Object(o.b)("p",null,"When defining a new class, Pyre will error if the base class given is not a valid parent class. This may be caused by various conditions:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"The parent class is marked as final which means it explicitly is annotated as not supporting child classes.")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"@final\nclass Base:\n  ...\n\nclass Derived(Base): # Invalid inheritance error\n  ...\n")),Object(o.b)("ol",{start:2},Object(o.b)("li",{parentName:"ol"},"The expression given in the base class field is not a class at all.")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'MY_GLOBAL: str = "string"\nclass Foo(MY_GLOBAL): # Invalid inheritance error\n  ...\n')),Object(o.b)("p",null,"Pyre does not support dynamic expressions as base classes, even if they may evaluate to a valid class at runtime. This is because the type checker relies on building up a valid class hierarchy before it can resolve types in the Python it is analyzing. On the other hand, type aliases are equivalent to types and are acceptable as base classes."),Object(o.b)("ol",{start:3},Object(o.b)("li",{parentName:"ol"},"You are defining a typed dictionary that does not inherit from another typed dictionary.")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"class NonTypedDict:\n  ...\n\nclass Movie(TypedDict):\n  name: str\n  year: int\n\nclass BookBasedMovie(Movie): # No error\n  based_on: str\n\nclass BookBasedMovie(NonTypedDict): # Invalid inheritance error\n  based_on: str\n")),Object(o.b)("p",null,"If inheriting from another typed dictionary, fields need to have a consistent type between child and parent, in order for subclassing to be sound. Similarly, a required field in the child must also be required for the parent."),Object(o.b)("h3",{id:"41-invalid-assignment"},"41: Invalid Assignment"),Object(o.b)("p",null,"Pyre will error on assignments to final attributes, read-only properties, and class variables from a class instance. For example,"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"class Foo:\n  field: Final[Optional[int]] = 1\n\n  def foo() -> None:\n    self.field = 2 # Invalid assignment\n\nclass Bar:\n    _x = 1\n    @property\n    def x(self) -> int:\n        return self._x\n\ndef bar(b: Bar) -> None:\n    b.x = 1 # Invalid assignment\n")),Object(o.b)("p",null,"To fix this error, change the definition of this attribute to something that is mutable, if it is not intended to be read-only."),Object(o.b)("h3",{id:"46-invalid-type-variance"},"46: Invalid type variance"),Object(o.b)("p",null,"In brief, read-only data types can be covariant, write-only data types can be contravariant, and data types that support both reads and writes must be invariant.\nIf a data type implements any functions accepting parameters of that type, we cannot guarantee that writes are not happening. If a data type implements any functions returning values of that type, we cannot guarantee that reads are not happening.\nFor example (note: int is a subclass of float in the type system and in these examples):\nWrites taking covariants:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'_T_co = typing.TypeVar("_T_co", covariant=True)\n\nclass MyList(typing.Generic[_T_co]):\n    def write(self, element: _T_co) -> None:\n        ... # adds element to list\n\ndef takes_float_list(float_list: MyList[float]) -> None:\n    float_list.write(1.0)\n\nint_list: MyList[int] = ...\ntakes_float_list(int_list)  # this call is OK because MyList is covariant: MyList[int] < MyList[float]\n# int_list contains floats\n')),Object(o.b)("p",null,"Reads returning contravariants:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'_T_cont = typing.TypeVar("_T_cont", contravariant=True)\n\nclass MyList(typing.Generic[_T_cont]):\n    def read(self) -> _T_cont:\n        ... # returns first element from list\n\ndef takes_int_list(int_list: MyList[int]) -> int:\n   return int_list.read()\n\nfloat_list: MyList[float] = ...\ntakes_int_list(float_list)  # this call is OK because MyList is contravariant: MyList[float] < MyList[int]\n# problem with return above is clear\n')),Object(o.b)("h3",{id:"49-unsafe-cast"},"49: Unsafe Cast"),Object(o.b)("p",null,"Pyre supports ",Object(o.b)("inlineCode",{parentName:"p"},"typing.cast")," to force the type checker to accept a given type for your expression, no matter what it would otherwise infer that type to be. This is a good escape hatch but can also hide type inconsistencies and introduce unsoundness. For example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def foo(x: int) -> str:\n    y = cast(str, x)\n    return y # No type error, even though this is unsound.\n")),Object(o.b)("p",null,"It is safe to broaden the inferred type of a variable. In other words, casting an expression to a more general type than the type checker thinks it has is sound. If you wish to broaden the inferred type without running the risk of introducing type inconsistencies, you can use ",Object(o.b)("inlineCode",{parentName:"p"},"pyre_extensions.safe_cast"),". This will warn if the type you are casting to is not greater than or equal to the inferred type of the expression."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def foo(x: int) -> str:\n    y = safe_cast(str, x) # Unsafe cast error\n    z = safe_cast(Union[int, str], x) # No error\n    return z # Invalid return type error\n")),Object(o.b)("h3",{id:"51-unused-local-mode"},"51: Unused Local Mode"),Object(o.b)("p",null,"Pyre only supports two modes of type checking, ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"types-in-python#gradual-typing"}),"unsafe")," and ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"types-in-python#strict-mode"}),"strict"),". By default, every file runs in unsafe mode, but you can change this default to strict in your ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"configuration#configuration-files"}),"configuration file"),"."),Object(o.b)("p",null,"You can also change the type checking mode of a single file by adding a local mode in the form of a ",Object(o.b)("inlineCode",{parentName:"p"},"# pyre-strict")," or ",Object(o.b)("inlineCode",{parentName:"p"},"# pyre-unsafe")," comment on its own line to the file header. This will ensure that file checks under the specified mode regardless of the default."),Object(o.b)("p",null,"If you specify more than one local mode, Pyre will error and ask you to remove all but one."),Object(o.b)("h3",{id:"40-invalid-override"},"40: Invalid Override"),Object(o.b)("p",null,"Pyre will error when methods in a child class override those in a parent class inconsistently.\nStatic methods cannot be overwritten by non-static methods, and final methods cannot be overwritten."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"class A:\n    @staticmethod\n    def foo(self) -> int:\n        pass\n\nclass B(A):\n    @classmethod # Non-static method `B.foo` cannot override a static method defined in `A`.\n    def foo(cls) -> int:\n        pass\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"  from typing import final\n  class Foo:\n    @final\n    def bar(self) -> None:\n      pass\n\n  class Bar(Foo):\n    def bar(self) -> None: # Invalid override [40]: `Bar.bar` cannot override final method defined in `Foo`.\n      pass\n")),Object(o.b)("h3",{id:"53-missing-annotation-for-captured-variables"},"53: Missing annotation for captured variables"),Object(o.b)("p",null,"Pyre makes no attempt at trying to infer the types across function boundaries. The statement holds for nested functions as well.\nFrom a nested function's perspective, a variable defined in an nesting function behaves not too differently from a global variable. Therefore, Pyre treats such variables in the same way as it treats global variable: an explicit annotation is required if strict mode is turned on."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def outer_function0() -> int:\n    x = foo()\n    def inner_function() -> int:\n        return x  # Due to the lack of explicit annotation, Pyre will treat this variable as having type `Any`.\n    return inner_function()\n\ndef outer_function1() -> int:\n    x: int = foo()\n    def inner_function() -> int:\n        return x  # This is ok: the type of `x` is known to be `int`.\n    return inner_function()\n\ndef outer_function2() -> int:\n    x = foo()\n    def inner_function(x: int) -> int:\n        return x  # This is also ok: even though the outer `x` is not annotated, the `x` parameter of the inner function is.\n    return inner_function(x)\n")),Object(o.b)("h3",{id:"56-invalid-decoration"},"56: Invalid decoration"),Object(o.b)("p",null,"This error code is a catch-all for a variety of problems that can arise in the course of resolving the type of a decorated function.\nIn all of these cases, these decoration failures will lead to the function being registered with type ",Object(o.b)("inlineCode",{parentName:"p"},"Any")," to avoid any spurious downstream errors."),Object(o.b)("h4",{id:"pyre-was-not-able-to-infer-the-type-of-the-decorator-"},'"Pyre was not able to infer the type of the decorator ..."'),Object(o.b)("p",null,"This should only happen when the decorator access itself is invalid, e.g. when you use a decorator which isn't declared in the stubs for a third-party library."),Object(o.b)("h4",{id:"pyre-was-not-able-to-infer-the-type-of-argument-"},'"Pyre was not able to infer the type of argument ..."'),Object(o.b)("p",null,'When using the "decorator factory" pattern, we need to resolve the type of both the decorator factory itself as well as the arguments passed to the decorator factory.\nThis is because the types of these arguments can alter the behavior of the returned decorator via overloads or type variables.\nHowever, this resolution has to happen early in the environment-building pipeline, when we don\'t yet have all of the context we need in order to resolve the types of arbitrary expressions.\nWe support resolving literals and simple globals as arguments, but using anything else will result in this error.'),Object(o.b)("p",null,"To work around this, you can statically type your arguments to the decorator factory as separate globals, which can be validated later in the type-checking pipeline."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'T = TypeVar("T")\ndef decorator_factory(x: T) -> Callable[[Callable[[int], str]], Callable[[str], T]]:\n  ...\n# pyre-fixme[56]: Pyre was not able to infer the type of argument\n#  `complex_expression()` to decorator factory `decorator_factory`.\n@decorator_factory(complex_expression())\ndef foo(x: int) -> str:\n  ...\n\n\nargument: float = complex_expression()\n\n@decorator_factory(argument) # Accepted!  bar resolves to Callable[[str], float]\ndef bar(x: int) -> str:\n  ...\n')),Object(o.b)("h4",{id:"decorator-factory-x-could-not-be-called"},'"Decorator factory ',"`","X","`",' could not be called"'),Object(o.b)("p",null,"This corresponds to when the decorator factory access resolves to a type that is not callable (i.e. has no ",Object(o.b)("inlineCode",{parentName:"p"},"__call__")," method)."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"not_a_factory: int = 5\n\n# pyre-fixme[56]: Decorator factory `not_a_factory` could not be called, because its\n# type `int` is not callable\n@not_a_factory(1)\ndef bar() -> None:\n  pass\n")),Object(o.b)("h4",{id:"decorator-x-could-not-be-called"},'"Decorator ',"`","X","`",' could not be called"'),Object(o.b)("p",null,"Similarly, these errors correspond to when the entire decorator expression (potentially including arguments to a decorator factory), resolves to a non-callable type."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def foo() -> int:\n  return 42\n\n# pyre-fixme[56]: Decorator `foo()` could not be called, because its\n# type `int` is not callable\n@foo()\ndef bar() -> None:\n  pass\n")),Object(o.b)("h4",{id:"while-applying-decorator-factory-"},'"While applying decorator factory ..."'),Object(o.b)("p",null,"These errors are emitted from attempting to pass the resolved factory arguments to the factory, as with any other function call."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def factory(x: str) -> Callable[[object], object]:\n  ...\n\n# pyre-fixme[56]: While applying decorator factory `factory`:\n# Expected `str` for 1st param but got `int`.\n@factory(1)\ndef foo() -> None:\n  pass\n")),Object(o.b)("h4",{id:"while-applying-decorator-"},'"While applying decorator ..."'),Object(o.b)("p",null,"Correspondingly, these errors are emitted from trying to pass the decorated function as an argument to the resolved decorator type."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def decorator(f: Callable[[int], str]) -> int:\n  ...\n\n# pyre-fixme[56]: While applying decorator `decorator`:\n# Expected `Callable[[int], str]` for 1st param but got `Callable[[str], int]`.\n@decorator\ndef foo(x: str) -> int:\n  return 5\n")),Object(o.b)("h3",{id:"57-incompatible-async-generator-return-type"},"57: Incompatible async generator return type"),Object(o.b)("p",null,"An async generator function is an ",Object(o.b)("inlineCode",{parentName:"p"},"async")," function that contains at least one ",Object(o.b)("inlineCode",{parentName:"p"},"yield")," statement. The Python runtime ensures that all async generator would return an async generator object. Therefore, the return type of async generator functions should always be ",Object(o.b)("inlineCode",{parentName:"p"},"typing.AsyncGenerator")," or one of its supertypes."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"async def f() -> int:  # Error\n  yield 0\n\nfrom typing import AsyncGenerator\nasync def g() -> AsyncGenerator[int, None]:  # OK\n  if False:\n    yield 1\n")),Object(o.b)("h2",{id:"suppression"},"Suppression"),Object(o.b)("p",null,"It is not always possible to address all errors immediately \u2013\xa0some code is too dynamic and should be refactored, other times it's ",Object(o.b)("em",{parentName:"p"},"just not the right time")," to deal with a type error. We do encourage people to keep their type check results clean at all times and provide mechanisms to suppress errors that cannot be immediately fixed."),Object(o.b)("h3",{id:"suppressing-individual-errors"},"Suppressing Individual Errors"),Object(o.b)("p",null,"Pyre supports error suppression of individual errors with comments that can be placed on the line of the error or on the line preceding the error."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"# pyre-fixme")," indicates there is an issue in the code that will be revisited later."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"# pyre-ignore")," indicates there's an issue with the type checker or the code is too dynamic and we have decided to not fix this. If this is a Pyre bug, make sure you ",Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://github.com/facebook/pyre/issues"}),"open an issue")," on our tracker.")),Object(o.b)("p",null,"Both comment styles allow you to suppress individual error codes as well as adding additional context."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'def foo() -> int:\n    # pyre-fixme[7]: only suppresses return mismatches\n    return ""\n')),Object(o.b)("p",null,"Pyre also supports ",Object(o.b)("inlineCode",{parentName:"p"},"# type: ignore")," comments for backwards-compatibility with ",Object(o.b)("em",{parentName:"p"},"mypy"),"."),Object(o.b)("h3",{id:"suppressing-all-errors"},"Suppressing All Errors"),Object(o.b)("p",null,"You can use the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"types-in-python#upgrade"}),"Pyre upgrade tool")," to add inline error suppressions for all errors in your project."),Object(o.b)("h3",{id:"suppressing-errors-across-files"},"Suppressing Errors Across Files"),Object(o.b)("p",null,"You can suppress all errors in entire sections of your code by adding the path to the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"configuration#global"}),Object(o.b)("inlineCode",{parentName:"a"},"ignore_all_errors")," section of your configuration"),"."),Object(o.b)("p",null,"Furthermore Pyre supports suppressing all errors in an individual file if you add a ",Object(o.b)("inlineCode",{parentName:"p"},"# pyre-ignore-all-errors")," to your file. Like the other suppression comments, you can use square brackets to chose to only ignore one or more particular error types."))}d.isMDXComponent=!0},99:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return h}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),p=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},b=function(e){var t=p(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),b=p(n),u=a,h=b["".concat(o,".").concat(u)]||b[u]||d[u]||i;return n?r.a.createElement(h,l(l({ref:t},c),{},{components:n})):r.a.createElement(h,l({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);