(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{75:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return u}));var a=n(2),i=n(6),o=(n(0),n(81)),s={id:"pysa-basics",title:"Overview",sidebar_label:"Overview"},r={unversionedId:"pysa-basics",id:"pysa-basics",isDocsHomePage:!1,title:"Overview",description:"Pyre has applications beyond type checking python code: it can also run static",source:"@site/docs/pysa_basics.md",permalink:"/docs/pysa-basics",sidebar_label:"Overview",sidebar:"documentation",previous:{title:"Querying Pyre",permalink:"/docs/querying-pyre"},next:{title:"Running Pysa",permalink:"/docs/pysa-running"}},l=[{value:"Taint Analysis",id:"taint-analysis",children:[]},{value:"Configuration",id:"configuration",children:[]},{value:"Sources",id:"sources",children:[]},{value:"Sinks",id:"sinks",children:[{value:"Implicit Sinks",id:"implicit-sinks",children:[]}]},{value:"Rules",id:"rules",children:[]},{value:"Sanitizers",id:"sanitizers",children:[]},{value:"Taint Propagation",id:"taint-propagation",children:[]},{value:"Features",id:"features",children:[]},{value:"Model files",id:"model-files",children:[{value:"Usage",id:"usage",children:[]},{value:"Requirements and Features",id:"requirements-and-features",children:[]}]}],c={rightToc:l};function u(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Pyre has applications beyond type checking python code: it can also run static\nanalysis, more specifically called ",Object(o.b)("strong",{parentName:"p"},"Taint Analysis"),", to identify potential security issues.\nThe Python Static Analyzer feature of Pyre is usually abbreviated to Pysa\n(pronounced like the Leaning Tower of Pisa)."),Object(o.b)("h2",{id:"taint-analysis"},"Taint Analysis"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Tainted data")," is data that must be treated carefully. Pysa works by tracking\nflows of data from where they originate (sources) to where they terminate in a\ndangerous location (sinks). For example, we might use it to track flows where\nuser-controllable request data flows into an ",Object(o.b)("inlineCode",{parentName:"p"},"eval")," call, leading to a remote\ncode execution vulnerability. This analysis is made possible by user-created\nmodels which provide annotations on source code, as well as rules that define\nwhich sources are dangerous for which sinks. Pysa comes with many pre-written\nmodels and rules for builtin and common python libraries."),Object(o.b)("p",null,"Pysa propagates taint as operations are performed on tainted data. For example,\nif we start with a tainted integer and perform a number of operations on it, the\nend results will still be tainted:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"x = some_function_that_returns_a_tainted_value() # 'x' is marked as tainted\ny = x + 10\ns = str(x)\nf = f\"Value = {s}\" # 'f' is marked with the same taint 'x' had\n")),Object(o.b)("p",null,"Pysa will only analyze the code in the repo that it runs on, as well as code in\ndirectories listed in the ",Object(o.b)("inlineCode",{parentName:"p"},"search_path")," of your\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/configuration"}),Object(o.b)("inlineCode",{parentName:"a"},".pyre_configuration"))," file. It does not see the source of\nyour dependencies. ",Object(o.b)("strong",{parentName:"p"},"Just because")," ",Object(o.b)("strong",{parentName:"p"},Object(o.b)("em",{parentName:"strong"},"you"))," ",Object(o.b)("strong",{parentName:"p"},"can see code in your editor\ndoes not mean Pysa has access to that code during analysis.")," Because of this\nlimitation, Pysa makes some simplifying assumptions. If taint flows into a\nfunction Pysa doesn't have the source for, it will assume that the return type\nof that function has the same taint. This helps prevents false negatives, but can\nalso lead to false positives."),Object(o.b)("p",null,"When an object is tainted, that means that all attributes of that object are\nalso tainted. Note that this is another source of potential false positives,\nsuch as taint flows that include ",Object(o.b)("inlineCode",{parentName:"p"},"some_obj.__class__"),". This means that Pysa\nwill detect all of the following flows:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"x = some_source() # 'x' is marked as tainted\n\nsome_sink(x) # This is detected\nsome_sink(x.some_attribute) # This is also detected\nsome_sink(x.__class__) # This is (unfortunately) also detected\n")),Object(o.b)("h2",{id:"configuration"},"Configuration"),Object(o.b)("p",null,"Pysa uses two types of files for configuration: a single ",Object(o.b)("inlineCode",{parentName:"p"},"taint.config")," file,\nand an unlimited number of files with a ",Object(o.b)("inlineCode",{parentName:"p"},".pysa")," extension. The ",Object(o.b)("inlineCode",{parentName:"p"},"taint.config"),"\nfile is a JSON document which stores definitions for ",Object(o.b)("em",{parentName:"p"},"sources"),", ",Object(o.b)("em",{parentName:"p"},"sinks"),", ",Object(o.b)("em",{parentName:"p"},"features"),",\nand ",Object(o.b)("em",{parentName:"p"},"rules")," (discussed below). The ",Object(o.b)("inlineCode",{parentName:"p"},".pysa")," files are model files (also discussed\nbelow) which annotate your code with the ",Object(o.b)("em",{parentName:"p"},"sources"),", ",Object(o.b)("em",{parentName:"p"},"sinks"),", and ",Object(o.b)("em",{parentName:"p"},"features")," defined in\nyour ",Object(o.b)("inlineCode",{parentName:"p"},"taint.config")," file. Examples of these files can be found in the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/facebook/pyre-check/tree/master/stubs/taint"}),"Pyre\nrepository"),"."),Object(o.b)("p",null,"These files live in the directory configured by ",Object(o.b)("inlineCode",{parentName:"p"},"taint_models_path")," in your\n",Object(o.b)("inlineCode",{parentName:"p"},".pyre_configuration")," file. Any ",Object(o.b)("inlineCode",{parentName:"p"},".pysa")," file found in this folder will be parsed\nby Pysa and the models will be used during the analysis."),Object(o.b)("h2",{id:"sources"},"Sources"),Object(o.b)("p",null,"Sources are where tainted data originates. They are declared in your\n",Object(o.b)("inlineCode",{parentName:"p"},"taint.config")," file like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'"sources": [\n    {\n        "name": "Cookies",\n        "comment": "used to annotate cookie sources"\n    },\n]\n')),Object(o.b)("p",null,"Models that indicate what is a source are then defined in ",Object(o.b)("inlineCode",{parentName:"p"},".pysa"),"\nfiles. Sources are declared with the same syntax as ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.python.org/3/library/typing.html"}),"type annotations in Python\n3"),". Function return types,\nclass/model attributes, and even entire classes can be declared as sources by\nadding ",Object(o.b)("inlineCode",{parentName:"p"},"TaintSource[SOURCE_NAME]")," wherever you would add a python type:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"# Function return source\ndef django.http.request.HttpRequest.get_signed_cookie(\n    self,\n    key,\n    default=...,\n    salt=...,\n    max_age=...\n) -> TaintSource[Cookies]: ...\n\n# Class attribute source:\ndjango.http.request.HttpRequest.COOKIES: TaintSource[Cookies] = ...\n")),Object(o.b)("p",null,"When tainting an entire class, any return from a method or access of an\nattribute of the class will count as a returning tainted data. The specifics of\nthese model files are discussed further in the Models section."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"# Class source:\nclass BaseException(TaintSource[Exception]): ...\n")),Object(o.b)("p",null,"When tainting indexable return types such as ",Object(o.b)("inlineCode",{parentName:"p"},"Dict"),"s, ",Object(o.b)("inlineCode",{parentName:"p"},"List"),"s, and ",Object(o.b)("inlineCode",{parentName:"p"},"Tuple"),"s, the\n",Object(o.b)("inlineCode",{parentName:"p"},"AppliesTo")," syntax can be used to only mark a portion of the return type as\ntainted:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),'def applies_to_index.only_applies_to_nested() -> AppliesTo[0, AppliesTo[1, TaintSource[Test]]]: ...\ndef applies_to_index.only_applies_to_a_key() -> AppliesTo["a", TaintSource[Test]]: ...\n')),Object(o.b)("h2",{id:"sinks"},"Sinks"),Object(o.b)("p",null,"Sinks are where tainted data terminates. They are declared in your\n",Object(o.b)("inlineCode",{parentName:"p"},"taint.config")," file like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'"sinks": [\n  {\n    "name": "SQL",\n    "comment": "use to annotate places of SQL injection risk"\n  }\n]\n')),Object(o.b)("p",null,"Models that indicate what is a sink are then defined in ",Object(o.b)("inlineCode",{parentName:"p"},".pysa")," files. Sinks can\nbe added to the same files as sources. Like sources, sinks are declared with\nthe same syntax as ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.python.org/3/library/typing.html"}),"type annotations in Python\n3"),". Function parameters and even\nwhole classes can be declared as sinks by adding ",Object(o.b)("inlineCode",{parentName:"p"},"TaintSink[SINK_NAME]")," where\nyou would add a python type:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"# Function parameter sink\ndef sqlite3.dbapi2.Cursor.execute(self, sql: TaintSink[SQL], parameters): ...\n")),Object(o.b)("p",null,"When tainting an entire class, any flow into a method or attribute of the class\nwill count as a flow to a taint sink. The specifics of these model files are\ndiscussed further in the Models section."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"# Entire class sink\nclass BaseException(TaintSink[Logging]): ...\n")),Object(o.b)("h3",{id:"implicit-sinks"},"Implicit Sinks"),Object(o.b)("p",null,"Implicit sinks are program expressions that we want to act as sinks, but that\ncannot be specified via taint signatures in ",Object(o.b)("inlineCode",{parentName:"p"},".pysa")," files.  Currently, only\nconditional tests are supported as implicit sinks. This allows writing rules\nthat track whether a particular source is used in a conditional test\nexpression."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'"implicit_sinks": {\n  "conditional_test": [ <your kind> ]\n}\n')),Object(o.b)("h2",{id:"rules"},"Rules"),Object(o.b)("p",null,"Rules declare which flows from source to sink we are concerned about. They are\ndeclared in your ",Object(o.b)("inlineCode",{parentName:"p"},"taint.config")," file like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'"rules": [\n  {\n    "name": "SQL injection.",\n    "code": 1,\n    "sources": [ "UserControlled" ],\n    "sinks": [ "SQL" ],\n    "message_format": "Data from [{$sources}] source(s) may reach [{$sinks}] sink(s)"\n  }\n]\n')),Object(o.b)("p",null,"Each rule needs a brief ",Object(o.b)("inlineCode",{parentName:"p"},"name")," that explains its purpose and a ",Object(o.b)("em",{parentName:"p"},"unique")," ",Object(o.b)("inlineCode",{parentName:"p"},"code"),".\nThe rule must define a list of one or more ",Object(o.b)("inlineCode",{parentName:"p"},"sources"),", which we are concerned\nabout flowing into one or more ",Object(o.b)("inlineCode",{parentName:"p"},"sinks"),". ",Object(o.b)("inlineCode",{parentName:"p"},"message_format")," can further explain the\nissue. When a flow is detected the ",Object(o.b)("inlineCode",{parentName:"p"},"{$sources}")," and ",Object(o.b)("inlineCode",{parentName:"p"},"{$sinks}")," variables will be\nreplaced with the name of the specific source(s) and sink(s) that were involved\nin the detected flow."),Object(o.b)("h2",{id:"sanitizers"},"Sanitizers"),Object(o.b)("p",null,"Sanitizers break a taint flow by removing taint from data. Models that indicate\nsanitizing functions are defined in ",Object(o.b)("inlineCode",{parentName:"p"},".pysa")," files. Sanitizers can be added to\nthe same files as sources and sinks. Functions are declared as sanitizers by\nadding a special decorator:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"# This will remove any taint passing through a function, regardless of whether\n# it is a taint source returned by this function, taint reaching sinks within\n# the function via 'argument', or taint propagateing through 'argument' to the\n# return value.\n@Sanitize\ndef django.utils.html.escape(text): ...\n")),Object(o.b)("p",null,"Sanitizers can also be scoped to only remove taint sources, sinks, or\ntaint-in-taint-oug (TITO), rather than all taint that passes through the\nfunction:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"# This will remove any taint sources returned by this function, but allow taint\n# to reach sinks within the function via 'argument' as well as allow taint to\n# propagate through 'argument' to the return value.\n@Sanitize(TaintSource)\ndef module.sanitize_source(argument): ...\n\n# This remove any taint which passes through 'argument' to reach a sink within\n# the function, but allow taint sources to be returned from the function as well\n# as allow taint to propagate through 'argument' to the return value.\n@Sanitize(TaintSink)\ndef module.sanitize_sink(argument): ...\n\n# This will remove any taint which propagates through 'argument' to the return\n# value, but allow taint sources to be returned from the function as well as\n# allow taint to reach sinks within the function via 'argument'.\n@Sanitize(TaintInTaintOut)\ndef module.sanitize_tito(argument): ...\n")),Object(o.b)("p",null,"Attributes can also be marked as sanitizers to remove all taint passing through\nthem:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"django.http.request.HttpRequest.GET: Sanitize = ...\n")),Object(o.b)("p",null,"This annotation is useful in the case of explicit sanitizers such as ",Object(o.b)("inlineCode",{parentName:"p"},"escape"),",\nwhich helps prevent cross site scripting (XSS) by escaping HTML characters. The\nannotation is also useful, however, in cases where a function is not intended to\nsanitize inputs, but is known to always return safe data despite touching\ntainted data. One such example could be ",Object(o.b)("inlineCode",{parentName:"p"},"hmac.digest(key, msg, digest)"),", which\nreturns sufficiently unpredictable data that the output should no longer be\nconsidered attacker-controlled after passing through."),Object(o.b)("p",null,"Note that sanitizers are currently universal, meaning that they remove all taint\nand can't be restricted to a specific rule or individual source to sink flows.\nThis means you need to ensure you aren't potentially affecting other flows when\nyou add a sanitizer for a flow you care about. For this reason, the above\nsanitizer examples might not be a good idea to use. If you are trying to track\nflows where SQL injection occurs, the ",Object(o.b)("inlineCode",{parentName:"p"},"escape")," sanitizer would prevent you\nfrom seeing any flows where data going into your SQL query happened to be HTML\nescaped."),Object(o.b)("h2",{id:"taint-propagation"},"Taint Propagation"),Object(o.b)("p",null,"Sometimes the features discussed in the Taint Analysis section are not enough to\ndetect all taint flows. In particular, Pysa relies on additional annotations to\nhelp it understand when an object is tainted via a function call or when a\nfunction call on a tainted object returns tainted data. Taint propagation is\ndefined by adding ",Object(o.b)("inlineCode",{parentName:"p"},"TaintInTaintOut")," annotations to models in ",Object(o.b)("inlineCode",{parentName:"p"},".pysa")," files."),Object(o.b)("p",null,"When a function call taints an object, such as when you update a dictionary with\na tainted value, Pysa needs a ",Object(o.b)("inlineCode",{parentName:"p"},"TaintInTaintOut")," annotation that indicates\n",Object(o.b)("inlineCode",{parentName:"p"},"Updates[self]"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"def dict.update(self, __m: TaintInTaintOut[Updates[self]]): ...\n")),Object(o.b)("p",null,"When a function call on a tainted object returns taint, such as when you\nretrieve a value from a dictionary, Pysa needs a ",Object(o.b)("inlineCode",{parentName:"p"},"TaintInTaintOut")," annotation\nthat indicates ",Object(o.b)("inlineCode",{parentName:"p"},"LocalReturn"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"def dict.get(self: TaintInTaintOut[LocalReturn], key, default = ...): ...\n")),Object(o.b)("h2",{id:"features"},"Features"),Object(o.b)("p",null,"Feature annotations are also placed in your ",Object(o.b)("inlineCode",{parentName:"p"},"taint.config")," and ",Object(o.b)("inlineCode",{parentName:"p"},".pysa")," files.\nThis is a larger topic and will be covered in detail on ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/pysa-features"}),"its own page"),"."),Object(o.b)("h2",{id:"model-files"},"Model files"),Object(o.b)("h3",{id:"usage"},"Usage"),Object(o.b)("p",null,"By default, Pysa computes an inferred model for each function and combines it\nwith any declared models in ",Object(o.b)("inlineCode",{parentName:"p"},".pysa")," files (of which there can be more than one).\nThe union of these models and their annotations will be used. For example,\ncookies are both user controlled and potentially sensitive to log, and Pysa\nallows us apply two different annotations to them:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"django.http.request.HttpRequest.COOKIES: TaintSource[UserControlled] = ...\ndjango.http.request.HttpRequest.COOKIES: TaintSource[Cookies] = ...\n")),Object(o.b)("h3",{id:"requirements-and-features"},"Requirements and Features"),Object(o.b)("h4",{id:"fully-qualified-names"},"Fully qualified names"),Object(o.b)("p",null,"Any declarations in ",Object(o.b)("inlineCode",{parentName:"p"},".pysa")," files must use the fully qualified name for the\nfunction/attribute they are attempting to annotate. You can usually find the\nfully qualified name for a type by looking at how it is imported, however, it's\nimportant to note that fully qualified names correspond to where something is\ndeclared, not necessarily where it is imported from. For example, you can import\n",Object(o.b)("inlineCode",{parentName:"p"},"HttpRequest")," directly from the ",Object(o.b)("inlineCode",{parentName:"p"},"django.http")," module, even though it is defined in\n",Object(o.b)("inlineCode",{parentName:"p"},"django.http.request"),". If you wanted to taint an attribute of ",Object(o.b)("inlineCode",{parentName:"p"},"HttpRequest"),",\nyou would need to use the module in which it was defined:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"django.http.request.HttpRequest.GET: TaintSource[UserControlled] = ...\n")),Object(o.b)("h4",{id:"matching-signatures"},"Matching signatures"),Object(o.b)("p",null,"The signature of any modeled function needs to match the signature of the\nfunction, as seen by Pyre. Note that Pyre doesn't always see the definition of\nthe of the functions directly. If ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.python.org/dev/peps/pep-0484/#stub-files"}),Object(o.b)("inlineCode",{parentName:"a"},".pyi")," stub\nfiles")," are present, Pyre\nwill use the signatures from those files, rather than the actual signature from\nthe function definition in your or your dependencies' code. See the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/types-in-python"}),"Gradual\nTyping page")," for more info about these ",Object(o.b)("inlineCode",{parentName:"p"},".pyi")," stubs."),Object(o.b)("p",null,"This matching signature requirement means that all required parameters\n(parameters without a default arugment), must be present in your model and named\nidentically to the parameters in the corresponding code or ",Object(o.b)("inlineCode",{parentName:"p"},".pyi")," file.\nParameters with default arguments, ",Object(o.b)("inlineCode",{parentName:"p"},"*args"),", and ",Object(o.b)("inlineCode",{parentName:"p"},"**kwargs")," may be included, but\nare not required. When copying parameters to your model, all type information\nmust be removed, and all default values must be elided (see below)."),Object(o.b)("p",null,"If a function includes an ",Object(o.b)("inlineCode",{parentName:"p"},"*")," that indicates ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.python.org/dev/peps/pep-3102/"}),"keyword only\nparameters"),", or a ",Object(o.b)("inlineCode",{parentName:"p"},"/")," that indicates\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.python.org/dev/peps/pep-0570/"}),"positional-only parameters"),", then\nthat may be included in your model."),Object(o.b)("p",null,"For example, ",Object(o.b)("inlineCode",{parentName:"p"},"urllib.request.urlopen")," has the following signature:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT, *, cafile=None,\n            capath=None, cadefault=False, context=None):\n")),Object(o.b)("p",null,"Given that signature, either of the following models are acceptable:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"def urllib.request.urlopen(url: TaintSink[RequestSend], data = ...,\n                           timeout = ..., *, cafile = ..., capath = ...,\n                           cadefault = ..., context = ...): ...\ndef urllib.request.urlopen(url: TaintSink[RequestSend]): ...\n")),Object(o.b)("p",null,"Pysa will complain if the signature of your model doesn't match the\nimplementation. When working with functions defined outside your project, where\nyou don't directly see the source, you can use ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/querying-pyre"}),Object(o.b)("inlineCode",{parentName:"a"},"pyre query")),"\nwith the ",Object(o.b)("inlineCode",{parentName:"p"},"signature")," argument to have Pysa dump it's internal model of a\nfunction, so you know exactly how to write your model."),Object(o.b)("h4",{id:"eliding"},"Eliding"),Object(o.b)("p",null,"As you can see from the above examples, defaulted values and function bodies can\nboth be elided with ",Object(o.b)("inlineCode",{parentName:"p"},"..."),". Additionally, type annotations ",Object(o.b)("em",{parentName:"p"},"must")," be entirely\nomitted (not replaced with ",Object(o.b)("inlineCode",{parentName:"p"},"..."),"), even when present on the declaration of the\nfunction. This is done to make parsing taint annotations unambiguous."))}u.isMDXComponent=!0},81:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return h}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),u=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=u(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},b=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(n),b=a,h=p["".concat(s,".").concat(b)]||p[b]||d[b]||o;return n?i.a.createElement(h,r(r({ref:t},c),{},{components:n})):i.a.createElement(h,r({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=b;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:a,s[1]=r;for(var c=2;c<o;c++)s[c]=n[c];return i.a.createElement.apply(null,s)}return i.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);